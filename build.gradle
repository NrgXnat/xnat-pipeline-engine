/*
 * pipeline: build.gradle
 * XNAT http://www.xnat.org
 * Copyright (c) 2017, Washington University School of Medicine
 * All Rights Reserved
 *
 * Released under the Simplified BSD.
 */

import org.apache.tools.ant.filters.FixCrLfFilter
import org.apache.tools.ant.filters.ReplaceTokens
import org.apache.tools.ant.taskdefs.condition.Os

plugins {
    id 'java'
}

def vXnat = "1.7.3-SNAPSHOT"
def vSpring = "4.2.9.RELEASE"
def vJackson = "2.6.5"
def vSlf4j = "1.7.21"
def vLog4j = "1.2.17"
def id = "xnat-pipeline-${vXnat}"

group 'org.nrg.xnat'
version = vXnat

repositories {
    jcenter()
    mavenCentral()
    maven {
        url 'http://www.dcm4che.org/maven2'
        name 'dcm4che Maven Repository'
    }
    maven {
        url 'https://nrgxnat.jfrog.io/nrgxnat/libs-release'
        name 'XNAT Release Repository'
    }
    maven {
        url 'https://nrgxnat.jfrog.io/nrgxnat/libs-snapshot'
        name 'XNAT Snapshot Repository'
    }
    maven {
        url 'https://nrgxnat.jfrog.io/nrgxnat/ext-release'
        name 'XNAT External Release Repository'
    }
}

sourceCompatibility = 1.7
targetCompatibility = 1.7

def String propertyWithDefault(def String property, def Object value) {
    hasProperty(property) ? getProperty(property) : value
}

// Marshall all of the variables and properties.
def isWindows = Os.isFamily(Os.FAMILY_WINDOWS)

def source = buildDir.parent
def destination = file(propertyWithDefault("destination", "${buildFile.parent}/build/pipeline"))
def url = "${propertyWithDefault("xnatUrl", "http://localhost:8080").replaceAll('/+$', '')}" as String
def email = "${propertyWithDefault("adminEmail", "admin@yourxnat.org")}" as String
def smtp = "${propertyWithDefault("smtpServer", "localhost")}" as String
def siteName = "${propertyWithDefault("siteName", "XNAT")}" as String

println """Building pipeline engine

 * From:        ${source}
 * To:          ${destination}
 * Email:       ${email}
 * Site name:   ${siteName}
 * Site URL:    ${url}
 * SMTP server: ${smtp}
"""

def configExt = (isWindows ? "bat" : "config") as String
def demoScript = (isWindows ? "demo.bat" : "demo.sh") as String
def envVar1 = (isWindows ? "%" : "\$") as String
def envVar2 = (isWindows ? "%" : "") as String
def classpathSeparator = (isWindows ? ";" : ":") as String
def osArgSym = (isWindows ? "%*" : "\$@") as String
def platformCall = (isWindows ? "call" : "source") as String
def shellLine = (isWindows ? "@echo off" : "#!/bin/bash") as String

def tokens = [CONFIG_EXT           : configExt,
              CP_SEP               : classpathSeparator,
              OS_ARG_SYM           : osArgSym,
              PIPELINE_DIR_PATH    : "${destination}" as String,
              PLATFORM_CALL        : platformCall,
              PLATFORM_ENV_VAR1    : envVar1,
              PLATFORM_ENV_VAR2    : envVar2,
              SCRIPT_NAME          : demoScript,
              SHELL_LINE           : shellLine,
              XNAT_SITE_NAME       : siteName,
              YOUR_EMAIL_HERE      : email,
              YOUR_SMTP_SERVER_HERE: smtp,
              YOUR_XNAT_URL_HERE   : url,
              XNAT_VERSION         : vXnat]

// Now get all of the script and resource folders.
def scripts = file("${source}/templates/scripts").exists() ? [file("${source}/templates/scripts")] : []
def resources = file("${source}/templates/resources").exists() ? [file("${source}/templates/resources")] : []
def binaries = file("${source}/templates/bin").exists() ? [file("${source}/templates/bin")] : []

def moduleRoots = file("${source}/modules").exists() ? [file("${source}/modules")] : []
if (hasProperty("modulePaths")) {
    "${modulePaths}".split(/\s*,\s*/).each { modulePath ->
        def path = file(modulePath)
        if (path.exists()) {
            println "Adding module root ${path}"
            moduleRoots.add path
        } else {
            println "The suggested module root ${path} does not exist, skipping."
        }
    }
}
println ""
moduleRoots.each { root ->
    root.eachDirMatch(~/^(?!\.).*/) { File module ->
        def folders = []
        module.eachDirMatch(~/resources/) { match ->
            folders.add match
        }
        module.eachDirMatch(~/scripts/) { match ->
            folders.add match
        }
        module.eachDirMatch(~/bin/) { match ->
            folders.add match
        }
        if (folders.size() == 0) {
            resources.add module
        } else {
            folders.each { File folder ->
                if (folder.name.endsWith("resources")) {
                    resources.add folder
                } else if (folder.name.endsWith("scripts")) {
                    scripts.add folder
                } else if (folder.name.endsWith("bin")) {
                    binaries.add folder
                }
            }
        }
    }
}

println "Resource folders:"
resources.each { resource ->
    println " * ${resource.path}"
}
println "Script folders:"
scripts.each { script ->
    println " * ${script.path}"
}
println "Binary folders:"
binaries.each { binary ->
    println " * ${binary.path}"
}
println ""

dependencies {
    compile("org.nrg.xnat:data-client:1.7.2") { transitive = false }
    compile("org.nrg.xnat:xnat-data-models:${vXnat}") { transitive = false }
    compile("org.nrg.xdat:core:${vXnat}") { transitive = false }
    compile("org.nrg:mail:${vXnat}") { transitive = false }
    compile("org.nrg:framework:${vXnat}") { transitive = false }
    compile("org.nrg:pipelineBase:1.0") { transitive = false }
    // compile("org.nrg:pipelineBuild:1.0") { transitive = false }
    compile("org.nrg:pipelineWorkflow:1.0") { transitive = false }
    compile("org.nrg:pipelineXNAT:1.0") { transitive = false }
    compile("org.nrg.xnat.pipeline:pipeline-client:${vXnat}") { transitive = false }
    compile("org.nrg.xnat.pipeline:xnat-pipeline:${vXnat}") { transitive = false }
    compile("org.nrg.xnat.pipeline:xnat-tools:${vXnat}") { transitive = false }
    compile("org.nrg.xnat:plexiviewer:${vXnat}") { transitive = false }
    compile("org.nrg.xnat.pipeline:imagingtools:${vXnat}") { transitive = false }
    compile("org.nrg.xnat:xnatsrb:1.0.1") { transitive = false }
    compile("org.springframework:spring-web:${vSpring}") { transitive = false }
    compile("org.springframework:spring-core:${vSpring}") { transitive = false }
    compile("org.springframework:spring-aop:${vSpring}") { transitive = false }
    compile("org.springframework:spring-beans:${vSpring}") { transitive = false }
    compile("org.springframework:spring-context:${vSpring}") { transitive = false }
    compile("commons-configuration:commons-configuration:1.10") { transitive = false }
    compile("commons-collections:commons-collections:3.2.1") { transitive = false }
    compile("commons-dbcp:commons-dbcp:1.2.1") { transitive = false }
    compile("commons-discovery:commons-discovery:0.5") { transitive = false }
    compile("commons-httpclient:commons-httpclient:3.1") { transitive = false }
    compile("commons-io:commons-io:2.4") { transitive = false }
    compile("commons-lang:commons-lang:2.6") { transitive = false }
    compile("commons-pool:commons-pool:1.2") { transitive = false }
    compile("commons-beanutils:commons-beanutils:1.9.2") { transitive = false }
    compile("commons-codec:commons-codec:1.10") { transitive = false }
    compile("commons-logging:commons-logging:1.2") { transitive = false }
    compile("org.apache.commons:commons-email:1.2") { transitive = false }
    compile("org.apache.commons:commons-lang3:3.4") { transitive = false }
    compile("org.apache.httpcomponents:fluent-hc:4.2.3") { transitive = false }
    compile("com.fasterxml.jackson.core:jackson-annotations:${vJackson}") { transitive = false }
    compile("com.fasterxml.jackson.core:jackson-core:${vJackson}") { transitive = false }
    compile("com.fasterxml.jackson.core:jackson-databind:${vJackson}") { transitive = false }
    compile("org.codehaus.jackson:jackson-core-asl:1.8.11") { transitive = false }
    compile("org.codehaus.jackson:jackson-mapper-asl:1.8.11") { transitive = false }
    compile("com.google.guava:guava:20.0") { transitive = false }
    compile("org.apache.httpcomponents:httpcore:4.4.5") { transitive = false }
    compile("org.apache.httpcomponents:httpclient:4.5.2") { transitive = false }
    compile("org.javassist:javassist:3.20.0-GA") { transitive = false }
    compile("org.dspace:jargon:1.4.25") { transitive = false }
    compile("javax.xml:jaxrpc-api:1.1") { transitive = false }
    compile("com.jcraft:jsch:0.1.24") { transitive = false }
    compile("javax.mail:mail:1.4.5") { transitive = false }
    compile("velocity:velocity:1.3.1") { transitive = false }
    compile("xalan:xalan:2.5.1") { transitive = false }
    compile("xerces:xercesImpl:2.4.0") { transitive = false }
    compile("xml-apis:xml-apis:1.0.b2") { transitive = false }
    compile("javax.activation:activation:1.1.1") { transitive = false }
    compile("ant:ant:1.6.1") { transitive = false }
    compile("axis:axis:1.4") { transitive = false }
    compile("net.sf.ezmorph:ezmorph:1.0.6") { transitive = false }
    compile("aopalliance:aopalliance:1.0") { transitive = false }
    compile("org.reflections:reflections:0.9.10") { transitive = false }
    compile("org.slf4j:slf4j-api:${vSlf4j}") { transitive = false }
    compile("org.slf4j:slf4j-log4j12:${vSlf4j}") { transitive = false }
    compile("org.slf4j:jul-to-slf4j:${vSlf4j}") { transitive = false }
    compile("log4j:log4j:${vLog4j}") { transitive = false }
    compile("net.sf.saxon:Saxon-B:9.0") { transitive = false }
}

// Pulls in the Jenkins BUILD_NUMBER environment variable if available.
def buildDate = new Date()
def buildNumber = System.getenv().BUILD_NUMBER?.toInteger() ?: "Manual"

logger.info "Build-Date:             ${buildDate}"
logger.info "Build-Number:           ${buildNumber}"
logger.info "Implementation-Version: ${version}"

task buildArchive(type: Zip) {
    manifest {
        attributes 'Application-Name': "XNAT Pipeline Engine ${vXnat}",
                'Build-Date': buildDate,
                'Build-Number': buildNumber,
                'Implementation-Version': version
        writeTo "${projectDir}/${id}.mf"
    }

    from("${projectDir}") {
        into "xnat-pipeline"
    }
    exclude "build/**"
    exclude "gradle.properties"
    exclude ".*"
    exclude ".*/**"
    archiveName "${id}.zip"
    destinationDir(file("${buildDir}/libs"))
}

task copyDependencies(type: Copy) {
    from configurations.runtime
    into "${destination}/lib"
}

task copyResources(type: Copy) {
    from resources
    into destination
    exclude '.*/**'
    filter(FixCrLfFilter)
    filter(ReplaceTokens, tokens: tokens)
}

task copyScripts(type: Copy) {
    from scripts
    into destination
    exclude '.*/**'
    fileMode 0755
    rename { String filename ->
        if (isWindows) {
            "${filename}.bat" as String
        } else {
            filename
        }
    }
    filter(FixCrLfFilter)
    filter(ReplaceTokens, tokens: tokens)
}

task copyBinaries(type: Copy) {
    from binaries
    into destination
    exclude '.*/**'
    fileMode 0755
}

task copyLibs(type: Copy) {
    from "${source}/lib"
    into "${destination}/lib"
    exclude '.*/**'
}

task copyBuildInfo(type: Copy) {
    from "${source}"
    into "${destination}"
    include "${id}.mf"
}

task copyAll {
    dependsOn tasks.matching { def Task task ->
        task instanceof Copy && task.name != "createDist"
    }
}

defaultTasks 'copyAll'

