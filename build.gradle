import org.apache.tools.ant.filters.FixCrLfFilter
import org.apache.tools.ant.filters.ReplaceTokens
import org.apache.tools.ant.taskdefs.condition.Os

apply plugin: "java"

repositories {
    mavenLocal()
    maven {
        url 'https://nrgxnat.artifactoryonline.com/nrgxnat/libs-release'
        name 'XNAT Release Repository'
    }
    maven {
        url 'https://nrgxnat.artifactoryonline.com/nrgxnat/libs-snapshot'
        name 'XNAT Snapshot Repository'
    }
    maven {
        url 'https://nrgxnat.artifactoryonline.com/nrgxnat/ext-release'
        name 'XNAT External Release Repository'
    }
    maven {
        url 'http://www.dcm4che.org/maven2'
        name 'dcm4che Maven Repository'
    }
    mavenCentral()
    jcenter()
}

sourceCompatibility = 1.7
targetCompatibility = 1.7

def vXnat = "1.7.0-SNAPSHOT"
def vSlf4j = '1.7.15'
def vLog4j = '1.2.17'

// Marshall all of the variables and properties.
def isWindows = Os.isFamily(Os.FAMILY_WINDOWS)

def source = buildDir.parent
def destination = !project.hasProperty("destination") ? file("${buildFile.parent}/build/pipeline") : file("${destination}") as String
def url = "${xnatUrl.replaceAll('/+$', '')}" as String
def email = "${adminEmail}" as String
def smtp = "${smtpServer}" as String
def siteName = "${siteName}" as String

println """Building pipeline engine

 * From:        ${source}
 * To:          ${destination}
 * Email:       ${email}
 * Site name:   ${siteName}
 * Site URL:    ${url}
 * SMTP server: ${smtp}
"""

def configExt = (isWindows ? "bat" : "config") as String
def demoScript = (isWindows ? "demo.bat" : "demo.sh") as String
def envVar1 = (isWindows ? "%" : "\$") as String
def envVar2 = (isWindows ? "%" : "") as String
def classpathSeparator = (isWindows ? ";" : ":") as String
def osArgSym = (isWindows ? "%*" : "\$@") as String
def platformCall = (isWindows ? "call" : "source") as String
def shellLine = (isWindows ? "@echo off" : "#!/bin/bash") as String

def tokens = [CONFIG_EXT           : configExt,
              CP_SEP               : classpathSeparator,
              OS_ARG_SYM           : osArgSym,
              PIPELINE_DIR_PATH    : "${destination}" as String,
              PLATFORM_CALL        : platformCall,
              PLATFORM_ENV_VAR1    : envVar1,
              PLATFORM_ENV_VAR2    : envVar2,
              SCRIPT_NAME          : demoScript,
              SHELL_LINE           : shellLine,
              XNAT_SITE_NAME       : siteName,
              YOUR_EMAIL_HERE      : email,
              YOUR_SMTP_SERVER_HERE: smtp,
              YOUR_XNAT_URL_HERE   : url]

// Now get all of the script and resource folders.
def scripts = file("${source}/templates/scripts").exists() ? [file("${source}/templates/scripts")] : []
def resources = file("${source}/templates/resources").exists() ? [file("${source}/templates/resources")] : []
def binaries = file("${source}/templates/bin").exists() ? [file("${source}/templates/bin")] : []

def moduleRoots = file("${source}/modules").exists() ? [file("${source}/modules")] : []
if (hasProperty("modulePaths")) {
    "${modulePaths}".split(/\s*,\s*/).each { modulePath ->
        def path = file(modulePath)
        if (path.exists()) {
            println "Adding module root ${path}"
            moduleRoots.add path
        } else {
            println "The suggested module root ${path} does not exist, skipping."
        }
    }
}
println ""
moduleRoots.each { root ->
    root.eachDirMatch(~/^(?!\.).*/) { File module ->
        def folders = []
        module.eachDirMatch(~/resources/) { match ->
            folders.add match
        }
        module.eachDirMatch(~/scripts/) { match ->
            folders.add match
        }
        module.eachDirMatch(~/bin/) { match ->
            folders.add match
        }
        if (folders.size() == 0) {
            resources.add module
        } else {
            folders.each { File folder ->
                if (folder.name.endsWith("resources")) {
                    resources.add folder
                } else if (folder.name.endsWith("scripts")) {
                    scripts.add folder
                } else if (folder.name.endsWith("bin")) {
                    binaries.add folder
                }
            }
        }
    }
}

println "Resource folders:"
resources.each { resource ->
    println " * ${resource.path}"
}
println "Script folders:"
scripts.each { script ->
    println " * ${script.path}"
}
println "Binary folders:"
binaries.each { binary ->
    println " * ${binary.path}"
}
println ""

dependencies {
    compile("org.nrg.xnat:data-client:${vXnat}") { transitive = false }
    compile("org.nrg.xnat:xnat-data-models:${vXnat}") { transitive = false }
    compile("org.nrg.xdat:core:${vXnat}") { transitive = false }
    compile("org.nrg:mail:${vXnat}") { transitive = false }
    compile("org.nrg:framework:${vXnat}") { transitive = false }
    compile("org.springframework:spring-web:4.2.5.RELEASE") { transitive = false }
    compile("org.springframework:spring-core:4.2.5.RELEASE") { transitive = false }
    compile("org.springframework:spring-aop:4.2.5.RELEASE") { transitive = false }
    compile("org.springframework:spring-beans:4.2.5.RELEASE") { transitive = false }
    compile("org.springframework:spring-context:4.2.5.RELEASE") { transitive = false }
    compile("commons-configuration:commons-configuration:1.10") { transitive = false }
    compile("org.apache.commons:commons-lang3:3.4") { transitive = false }
    compile("org.reflections:reflections:0.9.10") { transitive = false }
    compile "org.slf4j:slf4j-api:${vSlf4j}"
    compile "org.slf4j:slf4j-log4j12:${vSlf4j}"
    compile "org.slf4j:jul-to-slf4j:${vSlf4j}"
    compile "log4j:log4j:${vLog4j}"
}

task copyDependencies(type: Copy) {
    from configurations.runtime
    into "${destination}/lib"
}

task copyResources(type: Copy) {
    from resources
    into destination
    exclude '.*/**'
    filter(FixCrLfFilter)
    filter(ReplaceTokens, tokens: tokens)
}

task copyScripts(type: Copy) {
    from scripts
    into destination
    exclude '.*/**'
    fileMode 0755
    rename { String filename ->
        if (isWindows) {
            "${filename}.bat" as String
        } else {
            filename
        }
    }
    filter(FixCrLfFilter)
    filter(ReplaceTokens, tokens: tokens)
}

task copyBinaries(type: Copy) {
    from binaries
    into destination
    exclude '.*/**'
    fileMode 0755
}

task copyLibs(type: Copy) {
    from "${source}/lib"
    into "${destination}/lib"
    exclude '.*/**'
}

task copyAll {
    dependsOn tasks.withType(Copy)
}

defaultTasks 'copyAll'

